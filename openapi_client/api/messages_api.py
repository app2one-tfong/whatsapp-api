# coding: utf-8

"""
    Chat API SDK

    The SDK allows you to receive and send messages through your WhatsApp account. [Sign up now](https://app.chat-api.com/)  The Chat API is based on the WhatsApp WEB protocol and excludes the ban both when using libraries from mgp25 and the like. Despite this, your account can be banned by anti-spam system WhatsApp after several clicking the \"block\" button.  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: sale@chat-api.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (
    ApiTypeError,
    ApiValueError
)
from openapi_client.model_utils import (
    check_allowed_values,
    check_validations
)


class MessagesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

        def __forward_message(self, forward_message_request, **kwargs):  # noqa: E501
            """Forwarding messages to a new or existing chat.  # noqa: E501

            Only one of two parameters is needed to determine the destination - chatId or phone.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.forward_message(forward_message_request, async_req=True)
            >>> result = thread.get()

            :param async_req bool: execute request asynchronously
            :param ForwardMessageRequest forward_message_request: (required)
            :param _return_http_data_only: response data without head status
                code and headers
            :param _preload_content: if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            :param _request_timeout: timeout setting for this request. If one
                number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
            :return: SendMessageStatus
                If the method is called asynchronously, returns the request
                thread.
            """
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['forward_message_request'] = forward_message_request
            return self.call_with_http_info(**kwargs)

        self.forward_message = Endpoint(
            settings={
                'response_type': 'SendMessageStatus',
                'auth': [
                    'instanceId', 
                    'token'
                ],
                'endpoint_path': '/forwardMessage',
                'operation_id': 'forward_message',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'forward_message_request',
                ],
                'required': [
                    'forward_message_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'forward_message_request': 'ForwardMessageRequest',
                },
                'attribute_map': {
                },
                'location_map': {
                    'forward_message_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/x-www-form-urlencoded',
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__forward_message
        )

        def __get_messages(self, **kwargs):  # noqa: E501
            """Get a list of messages.  # noqa: E501

            To receive only new messages, pass the **lastMessageNumber** parameter from the last query.  Files from messages are guaranteed to be stored only for 30 days and can be deleted. Download the files as soon as you get to your server.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.get_messages(async_req=True)
            >>> result = thread.get()

            :param async_req bool: execute request asynchronously
            :param int last_message_number: The lastMessageNumber parameter from the last response
            :param bool last: Displays the last 100 messages. If this parameter is passed, then lastMessageNumber is ignored.
            :param str chat_id: Filter messages by chatId  Chat ID from the message list. Examples: 17633123456@c.us for private messages and 17680561234-1479621234@g.us for the group.
            :param int limit: Sets length of the message list. Default 100. With value 0 returns all messages.
            :param int min_time: Filter messages received after specified time. Example: 946684800.
            :param int max_time: Filter messages received before specified time. Example: 946684800.
            :param _return_http_data_only: response data without head status
                code and headers
            :param _preload_content: if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            :param _request_timeout: timeout setting for this request. If one
                number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
            :return: Messages
                If the method is called asynchronously, returns the request
                thread.
            """
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            return self.call_with_http_info(**kwargs)

        self.get_messages = Endpoint(
            settings={
                'response_type': 'Messages',
                'auth': [
                    'instanceId', 
                    'token'
                ],
                'endpoint_path': '/messages',
                'operation_id': 'get_messages',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'last_message_number',
                    'last',
                    'chat_id',
                    'limit',
                    'min_time',
                    'max_time',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'last_message_number',
                ]
            },
            root_map={
                'validations': {
                    ('last_message_number',): {

                        'inclusive_minimum': 0,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'last_message_number': 'int',
                    'last': 'bool',
                    'chat_id': 'str',
                    'limit': 'int',
                    'min_time': 'int',
                    'max_time': 'int',
                },
                'attribute_map': {
                    'last_message_number': 'lastMessageNumber',
                    'last': 'last',
                    'chat_id': 'chatId',
                    'limit': 'limit',
                    'min_time': 'min_time',
                    'max_time': 'max_time',
                },
                'location_map': {
                    'last_message_number': 'query',
                    'last': 'query',
                    'chat_id': 'query',
                    'limit': 'query',
                    'min_time': 'query',
                    'max_time': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__get_messages
        )

        def __send_contact(self, send_contact_request, **kwargs):  # noqa: E501
            """Sending a contact or contact list to a new or existing chat.  # noqa: E501

            Only one of two parameters is needed to determine the destination - chatId or phone.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.send_contact(send_contact_request, async_req=True)
            >>> result = thread.get()

            :param async_req bool: execute request asynchronously
            :param SendContactRequest send_contact_request: (required)
            :param _return_http_data_only: response data without head status
                code and headers
            :param _preload_content: if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            :param _request_timeout: timeout setting for this request. If one
                number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
            :return: SendMessageStatus
                If the method is called asynchronously, returns the request
                thread.
            """
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['send_contact_request'] = send_contact_request
            return self.call_with_http_info(**kwargs)

        self.send_contact = Endpoint(
            settings={
                'response_type': 'SendMessageStatus',
                'auth': [
                    'instanceId', 
                    'token'
                ],
                'endpoint_path': '/sendContact',
                'operation_id': 'send_contact',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'send_contact_request',
                ],
                'required': [
                    'send_contact_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'send_contact_request': 'SendContactRequest',
                },
                'attribute_map': {
                },
                'location_map': {
                    'send_contact_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/x-www-form-urlencoded',
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__send_contact
        )

        def __send_file(self, send_file_request, **kwargs):  # noqa: E501
            """Send a file to a new or existing chat.  # noqa: E501

            Only one of two parameters is needed to determine the destination - chatId or phone.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.send_file(send_file_request, async_req=True)
            >>> result = thread.get()

            :param async_req bool: execute request asynchronously
            :param SendFileRequest send_file_request: (required)
            :param _return_http_data_only: response data without head status
                code and headers
            :param _preload_content: if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            :param _request_timeout: timeout setting for this request. If one
                number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
            :return: SendMessageStatus
                If the method is called asynchronously, returns the request
                thread.
            """
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['send_file_request'] = send_file_request
            return self.call_with_http_info(**kwargs)

        self.send_file = Endpoint(
            settings={
                'response_type': 'SendMessageStatus',
                'auth': [
                    'instanceId', 
                    'token'
                ],
                'endpoint_path': '/sendFile',
                'operation_id': 'send_file',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'send_file_request',
                ],
                'required': [
                    'send_file_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'send_file_request': 'SendFileRequest',
                },
                'attribute_map': {
                },
                'location_map': {
                    'send_file_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/x-www-form-urlencoded',
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__send_file
        )

        def __send_link(self, send_link_request, **kwargs):  # noqa: E501
            """Send text with link and link's preview to a new or existing chat.  # noqa: E501

            Only one of two parameters is needed to determine the destination - chatId or phone.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.send_link(send_link_request, async_req=True)
            >>> result = thread.get()

            :param async_req bool: execute request asynchronously
            :param SendLinkRequest send_link_request: (required)
            :param _return_http_data_only: response data without head status
                code and headers
            :param _preload_content: if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            :param _request_timeout: timeout setting for this request. If one
                number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
            :return: SendMessageStatus
                If the method is called asynchronously, returns the request
                thread.
            """
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['send_link_request'] = send_link_request
            return self.call_with_http_info(**kwargs)

        self.send_link = Endpoint(
            settings={
                'response_type': 'SendMessageStatus',
                'auth': [
                    'instanceId', 
                    'token'
                ],
                'endpoint_path': '/sendLink',
                'operation_id': 'send_link',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'send_link_request',
                ],
                'required': [
                    'send_link_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'send_link_request': 'SendLinkRequest',
                },
                'attribute_map': {
                },
                'location_map': {
                    'send_link_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/x-www-form-urlencoded',
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__send_link
        )

        def __send_location(self, send_location_request, **kwargs):  # noqa: E501
            """Sending a location to a new or existing chat.  # noqa: E501

            Only one of two parameters is needed to determine the destination - chatId or phone.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.send_location(send_location_request, async_req=True)
            >>> result = thread.get()

            :param async_req bool: execute request asynchronously
            :param SendLocationRequest send_location_request: (required)
            :param _return_http_data_only: response data without head status
                code and headers
            :param _preload_content: if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            :param _request_timeout: timeout setting for this request. If one
                number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
            :return: SendMessageStatus
                If the method is called asynchronously, returns the request
                thread.
            """
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['send_location_request'] = send_location_request
            return self.call_with_http_info(**kwargs)

        self.send_location = Endpoint(
            settings={
                'response_type': 'SendMessageStatus',
                'auth': [
                    'instanceId', 
                    'token'
                ],
                'endpoint_path': '/sendLocation',
                'operation_id': 'send_location',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'send_location_request',
                ],
                'required': [
                    'send_location_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'send_location_request': 'SendLocationRequest',
                },
                'attribute_map': {
                },
                'location_map': {
                    'send_location_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/x-www-form-urlencoded',
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__send_location
        )

        def __send_message(self, send_message_request, **kwargs):  # noqa: E501
            """Send a message to a new or existing chat.  # noqa: E501

            The message will be added to the queue for sending and delivered even if the phone is disconnected from the Internet or authorization is not passed.  Only one of two parameters is needed to determine the destination - chatId or phone.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.send_message(send_message_request, async_req=True)
            >>> result = thread.get()

            :param async_req bool: execute request asynchronously
            :param SendMessageRequest send_message_request: (required)
            :param _return_http_data_only: response data without head status
                code and headers
            :param _preload_content: if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            :param _request_timeout: timeout setting for this request. If one
                number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
            :return: SendMessageStatus
                If the method is called asynchronously, returns the request
                thread.
            """
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['send_message_request'] = send_message_request
            return self.call_with_http_info(**kwargs)

        self.send_message = Endpoint(
            settings={
                'response_type': 'SendMessageStatus',
                'auth': [
                    'instanceId', 
                    'token'
                ],
                'endpoint_path': '/sendMessage',
                'operation_id': 'send_message',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'send_message_request',
                ],
                'required': [
                    'send_message_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'send_message_request': 'SendMessageRequest',
                },
                'attribute_map': {
                },
                'location_map': {
                    'send_message_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/x-www-form-urlencoded',
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__send_message
        )

        def __send_ptt(self, send_ptt_request, **kwargs):  # noqa: E501
            """Send a ptt-audio to a new or existing chat.  # noqa: E501

            Only one of two parameters is needed to determine the destination - chatId or phone.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.send_ptt(send_ptt_request, async_req=True)
            >>> result = thread.get()

            :param async_req bool: execute request asynchronously
            :param SendPTTRequest send_ptt_request: (required)
            :param _return_http_data_only: response data without head status
                code and headers
            :param _preload_content: if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            :param _request_timeout: timeout setting for this request. If one
                number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
            :return: SendMessageStatus
                If the method is called asynchronously, returns the request
                thread.
            """
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['send_ptt_request'] = send_ptt_request
            return self.call_with_http_info(**kwargs)

        self.send_ptt = Endpoint(
            settings={
                'response_type': 'SendMessageStatus',
                'auth': [
                    'instanceId', 
                    'token'
                ],
                'endpoint_path': '/sendPTT',
                'operation_id': 'send_ptt',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'send_ptt_request',
                ],
                'required': [
                    'send_ptt_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'send_ptt_request': 'SendPTTRequest',
                },
                'attribute_map': {
                },
                'location_map': {
                    'send_ptt_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/x-www-form-urlencoded',
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__send_ptt
        )

        def __send_v_card(self, send_v_card_request, **kwargs):  # noqa: E501
            """Sending a vcard to a new or existing chat.  # noqa: E501

            Only one of two parameters is needed to determine the destination - chatId or phone.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.send_v_card(send_v_card_request, async_req=True)
            >>> result = thread.get()

            :param async_req bool: execute request asynchronously
            :param SendVCardRequest send_v_card_request: (required)
            :param _return_http_data_only: response data without head status
                code and headers
            :param _preload_content: if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            :param _request_timeout: timeout setting for this request. If one
                number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
            :return: SendMessageStatus
                If the method is called asynchronously, returns the request
                thread.
            """
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['send_v_card_request'] = send_v_card_request
            return self.call_with_http_info(**kwargs)

        self.send_v_card = Endpoint(
            settings={
                'response_type': 'SendMessageStatus',
                'auth': [
                    'instanceId', 
                    'token'
                ],
                'endpoint_path': '/sendVCard',
                'operation_id': 'send_v_card',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'send_v_card_request',
                ],
                'required': [
                    'send_v_card_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'send_v_card_request': 'SendVCardRequest',
                },
                'attribute_map': {
                },
                'location_map': {
                    'send_v_card_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/x-www-form-urlencoded',
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__send_v_card
        )


class Endpoint(object):
    def __init__(self, settings=None, params_map=None, root_map=None,
                 headers_map=None, api_client=None, callable=None):
        """Creates an endpoint

        Args:
            settings (dict): see below key value pairs
                'response_type' (str): response type
                'auth' (list): a list of auth type keys
                'endpoint_path' (str): the endpoint path
                'operation_id' (str): endpoint string identifier
                'http_method' (str): POST/PUT/PATCH/GET etc
                'servers' (list): list of str servers that this endpoint is at
            params_map (dict): see below key value pairs
                'all' (list): list of str endpoint parameter names
                'required' (list): list of required parameter names
                'nullable' (list): list of nullable parameter names
                'enum' (list): list of parameters with enum values
                'validation' (list): list of parameters with validations
            root_map
                'validations' (dict): the dict mapping endpoint parameter tuple
                    paths to their validation dictionaries
                'allowed_values' (dict): the dict mapping endpoint parameter
                    tuple paths to their allowed_values (enum) dictionaries
                'openapi_types' (dict): param_name to openapi type
                'attribute_map' (dict): param_name to camelCase name
                'location_map' (dict): param_name to  'body', 'file', 'form',
                    'header', 'path', 'query'
                collection_format_map (dict): param_name to `csv` etc.
            headers_map (dict): see below key value pairs
                'accept' (list): list of Accept header strings
                'content_type' (list): list of Content-Type header strings
            api_client (ApiClient) api client instance
            callable (function): the function which is invoked when the
                Endpoint is called
        """
        self.settings = settings
        self.params_map = params_map
        self.params_map['all'].extend([
            'async_req',
            '_host_index',
            '_preload_content',
            '_request_timeout',
            '_return_http_data_only'
        ])
        self.validations = root_map['validations']
        self.allowed_values = root_map['allowed_values']
        self.openapi_types = root_map['openapi_types']
        self.attribute_map = root_map['attribute_map']
        self.location_map = root_map['location_map']
        self.collection_format_map = root_map['collection_format_map']
        self.headers_map = headers_map
        self.api_client = api_client
        self.callable = callable

    def __validate_inputs(self, kwargs):
        for param in self.params_map['enum']:
            if param in kwargs:
                check_allowed_values(
                    self.allowed_values,
                    (param,),
                    kwargs[param],
                    self.validations
                )

        for param in self.params_map['validation']:
            if param in kwargs:
                check_validations(
                    self.validations,
                    (param,),
                    kwargs[param]
                )

    def __gather_params(self, kwargs):
        params = {
            'body': None,
            'collection_format': {},
            'file': {},
            'form': [],
            'header': {},
            'path': {},
            'query': []
        }

        for param_name, param_value in six.iteritems(kwargs):
            param_location = self.location_map.get(param_name)
            if param_location:
                if param_location == 'body':
                    params['body'] = param_value
                    continue
                base_name = self.attribute_map[param_name]
                if (param_location == 'form' and
                        self.openapi_types[param_name] == 'file'):
                    param_location = 'file'
                elif param_location in {'form', 'query'}:
                    param_value_full = (base_name, param_value)
                    params[param_location].append(param_value_full)
                if param_location not in {'form', 'query'}:
                    params[param_location][base_name] = param_value
                collection_format = self.collection_format_map.get(param_name)
                if collection_format:
                    params['collection_format'][base_name] = collection_format

        return params

    def __call__(self, *args, **kwargs):
        """ This method is invoked when endpoints are called
        Example:
        pet_api = PetApi()
        pet_api.add_pet  # this is an instance of the class Endpoint
        pet_api.add_pet()  # this invokes pet_api.add_pet.__call__()
        which then invokes the callable functions stored in that endpoint at
        pet_api.add_pet.callable or self.callable in this class
        """
        return self.callable(self, *args, **kwargs)

    def call_with_http_info(self, **kwargs):

        if kwargs.get('_host_index') and self.settings['servers']:
            _host_index = kwargs.get('_host_index')
            try:
                _host = self.settings['servers'][_host_index]
            except IndexError:
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s" %
                    len(self.settings['servers'])
                )
        else:
            try:
                _host = self.settings['servers'][0]
            except IndexError:
                _host = None

        for key, value in six.iteritems(kwargs):
            if key not in self.params_map['all']:
                raise ApiTypeError(
                    "Got an unexpected parameter '%s'"
                    " to method `%s`" %
                    (key, self.settings['operation_id'])
                )
            if key not in self.params_map['nullable'] and value is None:
                raise ApiValueError(
                    "Value may not be None for non-nullable parameter `%s`"
                    " when calling `%s`" %
                    (key, self.settings['operation_id'])
                )

        for key in self.params_map['required']:
            if key not in kwargs.keys():
                raise ApiValueError(
                    "Missing the required parameter `%s` when calling "
                    "`%s`" % (key, self.settings['operation_id'])
                )

        self.__validate_inputs(kwargs)

        params = self.__gather_params(kwargs)

        accept_headers_list = self.headers_map['accept']
        if accept_headers_list:
            params['header']['Accept'] = self.api_client.select_header_accept(
                accept_headers_list)

        content_type_headers_list = self.headers_map['content_type']
        if content_type_headers_list:
            header_list = self.api_client.select_header_content_type(
                content_type_headers_list)
            params['header']['Content-Type'] = header_list

        return self.api_client.call_api(
            self.settings['endpoint_path'], self.settings['http_method'],
            params['path'],
            params['query'],
            params['header'],
            body=params['body'],
            post_params=params['form'],
            files=params['file'],
            response_type=self.settings['response_type'],
            auth_settings=self.settings['auth'],
            async_req=kwargs.get('async_req'),
            _return_http_data_only=kwargs.get('_return_http_data_only'),
            _preload_content=kwargs.get('_preload_content', True),
            _request_timeout=kwargs.get('_request_timeout'),
            _host=_host,
            collection_formats=params['collection_format'])
